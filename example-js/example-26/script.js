// regex101.com - лучший сайт для проверки регулярных выражений . Резюме что я понял по регулярным выражениям . Проверка идет последовательно с начала строки, символ ^ означает начало строки, но в выражении [^abc] означает дапазон какой-либо символ кроме а или b или с // * (после диапазона к примеру) говорит что символов может быть ноль и больше, если ее не ставить то сравнение будет только с первым символом в строке// 1) если регулярное выражение просто диапазон  [abc] что значит ( содержится хотя бы или a или b или с) то проверяя строку аааbbbcddd метод .test вернет true найдя в первом же символе a, если мы применим в регулярном выражении диапазон [bc] то метод начнет перебирать символы аааа и отклонять их пока не дойдет до b и вернет true// 2) если регулярное выражение диапазон "кроме исключения" "если какие-то символы кроме с " [^c] то проверяя строку аааbbbcddd метод .test вернет true так как первый же символ а, значит регулярное выражение содержится в строке// Проблема в том если мы хотим определить набор символов в регулярном выражении такиим образом что бы он четко определял каким символам можно присутсовать в строке что бы метод test выдавал true// Эта проблема решается несколькими способами.// Первый способ определить диапазон тех символов как те которые валидны как те которые не должны присутсвовать в строке. (То есть инверсивная логика) те которы нам нужны мы их исключаем то есть a b или с валидны для нас но мы берем диапазон [^abc]  (* - "ноль и более" тут не обязателен  так как достаточно одного символа который не входиь в диапазон abc ), то есть если какие либо символы кроме a или b или c содержатся в строке  то метод тест вернет нам true// а если в cтроке будут содержаться либо a либо b либо c либо вместе метод test вернет нам false (а нам надо бы true  в таком случае) или к примеру будет в строке хотя бы один символ к примеру d (не из нашего желаемых abc) метод test вернет true (если в строке будет нежелаемый символ нам бы надо что метод вернул false)// Все работает с точностью наоборот (но работает) Теперь нам остается в каких либо условиях функций применить оператор НЕ (!) и все встанет на свои места // к примеру: Нам нужно чтобы в строке были только символы от a  до z. Тогда пусть re = /[^a-z]*/, re.test('a') даст false, но !re.test('a') даст true (то что нам надо), а если в строке будет прсутсвовать к примеру цифра 9 то !re.test(a9bc) даст false (замечательно)
// Второй способ ииспользовать символы начала строки (^) и конца строки ($) строки тогда дииапазон применяется по сути без инверсиии к каждому элементу сроки Пример при re = /^[a-z]*$/ метод re.test('aabc') вернет true, а при выражении re.test(ab7c) метод вернет false
// const VALID_SYMBOLS = /^#[A-Za-zА-Яа-яЁё0-9]{1,19}$/; // это регулярное выражение было предложено на лайве, и оно работает (без инверсивной логики кстати ), но вцелях общего развития я отрежу от него часть отвечающую за количество символов а в коде добавлю дополнительную проверку,

const UNVALID_SYMBOLS = /[^A-Za-zА-Яа-яЁё0-9]/; // const hasValidSymbols = (string) => !UNVALID_SYMBOLS.test(string);

// const UNVALID_SYMBOLS = /[^a-zA-Z0-9а-яА-ЯёЁ]/g; // в коде проекта используется такое выражение, но как я понял оно инвертирует соответвие сравниваемых т е возвращает true когда срроа не содержится в регулрновм выражении // мои " исследования" привели к тому что если знак степени  ^ (начало строки)
