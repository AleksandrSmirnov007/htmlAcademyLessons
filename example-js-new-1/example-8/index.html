<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://zeckson.github.io/demo-console/2.2.1/index-silent.min.js"></script>
  <title>Метод fetch и промисы</title>
</head>
<body>
  <h1>Метод fetch и промисы. часть 2</h1> <br>
  Полученнме данных с сервера и их обработка в промисах: <br> <br>
  <pre>
  // Для проверки обработки ошибки изменим часть адреса,
  // заведомо указав несуществующий адрес /posts1
  fetch('https://jsonplaceholder.typicode.com/posts1')
    .then((response) => {
      if (response.ok) {
        return response;
      }

      throw new Error(`${response.status} — ${response.statusText}`);
    })
    .then((response) => response.json())
    .then((posts) => console.log(posts))
    .catch((error) => console.log(error));
  </pre>
  вывод в консоль
<!--
  В первом then выполняется проверка свойства ok. Если оно равно true, значит серверу есть, чем ответить. Можно возвращать объект ответа и продолжать конвейер обработки (обработать JSON и так далее).

  Если значение ok равно false, серверу нечем ответить, разумным решением в такой ситуации станет формирование объекта с ошибкой. Для этого бросим исключение с Error. Аргументами передадим значения свойств объекта ответа status (код ответа сервера) и statusText (пояснительная строка). -->
  <!-- Как только будет брошено исключение, оно переведёт промис в состояние завершён с ошибкой, и мы сможем перехватить его в catch, чтобы вывести в консоль содержимое ошибки. -->
  <!-- Если ошибку вернул не сервер, а, например, в момент запроса пропал интернет, в такой ситуации промис, возвращаемый fetch(), будет завершён с ошибкой. Следовательно, обработать такую ситуацию можно в методе catch. Поэтому не забывайте добавлять его в конце цепочки then! -->
  <script src="./script.js"></script>
</body>
</html>
