// Для создания слайдера, есть штатный элемент управления — input с типом range. Хорошая штука, но с рядом минусов. Например, ползунок может быть только один, стилизовать сложно и поддерживается стилизация не везде. Поэтому мы будем использовать стороннюю библиотеку noUiSlider для созданий слайдеров
// СКАЧАЛ ОБНОВЛЕНИЕ ОТ КЕКСА из домашнего задания в виде двух файлов в папке в корне проекта
// Первым делом нужно добавить элемент в html , в который библиотека будет отрисовывать слайдер. Заодно мы наверстаем небольшую форму.     <div class="level-form__slider" id="slider"></div>
// После подключить файл стилей и скрипт библиотеки. ( в демонстрации использованы интернет ресурсы     <link rel="stylesheet" href="https://unpkg.com/nouislider@14.6.3/distribute/nouislider.min.css">  и     <script src="https://unpkg.com/nouislider@14.6.3/distribute/nouislider.min.js"></script> надо будет попробовать с ними)


// также добавить стили для nouislider   <link rel="stylesheet" href="./nouislider/nouislider.css">
// После подключить файл стилей и скрипт библиотеки. в низу html перед хзакрывающим тегом боду       <script src="./nouislider/nouislider.js"></script>
// очень важно не забыть подключить этот файл скрипа!! в html (  <script src="./script.js"></script>)

// Создадим слайдер. Для этого воспользуемся методами глобального объекта noUiSlider. Мы передали noUiSlider элемент, в который просим отрисовать слайдер, а также минимальное и максимальное значение и шаг. Кстати, все возможности слайдера удобнее всего изучать в официальной документации noUiSlider.

// Сам по себе слайдер малопрактичен, поэтому самой частой задачей при работе с ним является подписка на события. Принцип работы один в один как со слушателями событий, только синтаксис отличается. Для примера добавим слайдеру слушатель события update, которое будет вызвано при изменении положения слайдера, и выводить в консоль параметры колбэка. Забегая вперёд, скажем, что положение может менять как пользователь руками, так и разработчик из JavaScript. Любое из этих изменений отловит update. Похожим образом можно подписаться на все события.
/* global noUiSlider:readonly */

const sliderElement = document.querySelector('.level-form__slider');
const valueElement = document.querySelector('.level-form__value');
// Начальное значение в поле ввода нужно будет записать самостоятельно. //   непонятно зачем ведь метод valueElement.value = sliderElement.noUiSlider.get(); возвращает значение сразу и даже если будет присвоено другое зщансчение изначально, метод его исправит
valueElement.value = 80;

const specialElement = document.querySelector('.level-form__special');

noUiSlider.create(sliderElement, {
  range: {
    min: 0,
    max: 100,
  },
  step: 1,
  start: 80,
  connect: 'lower', // Дополнительно можно указать, с какой стороны закрашивать слайдер. Например, от меньшего к большему значению.
  // Давайте разберёмся с этим самым обработчиком. Если вы обратили внимание, на предыдущих шагах в поле цена иногда попадали странные дробные числа. Чтобы этого не происходило, нужно взять форматирование в свои руки. Сперва начнём выводить в поле «Цена» обработанные значения, это первый параметр колбэка, если забыли.
  // Затем опишем методы форматирования. Метод .format.to() нужен для форматирования значения из слайдера и вывода его где-либо. Метод .format.from() нужен для форматирования значения для слайдера. Этот метод должен строго возвращать число, поэтому используем parseFloat(), и достаточно.
  // А вот с методом .format.to() нужно повозиться. Условия такие: если значение слайдера целое число, то нужно вывести его без дробной части; если значение дробное — с одним знаком после запятой. Для первого условия используем метод Number.isInteger(), он вернёт булево значение в зависимости от того, целое ли ему передано число. Например, число 7.0 метод считает целым, хотя запись дробная. Это то, что нам и нужно. А дальше дело техники. С помощью .toFixed() оставим нужное количество знаков после запятой.
  format: {
    to: function (value) {
      if (Number.isInteger(value)) {
        return value.toFixed(0); // если нужен вывод к примеру в процентах то можно использовать шаблонную строку return `${value.toFixed(0)} %`;
      } else{
      return value.toFixed(1);
      }
    },
    from: function (value) {
      return parseFloat(value);
    },
  },
});

// Сам по себе слайдер малопрактичен, поэтому самой частой задачей при работе с ним является подписка на события. Принцип работы один в один как со слушателями событий, только синтаксис отличается. Для примера добавим слайдеру слушатель события update, которое будет вызвано при изменении положения слайдера, и выводить в консоль параметры колбэка. Забегая вперёд, скажем, что положение может менять как пользователь руками, так и разработчик из JavaScript. Любое из этих изменений отловит update. Похожим образом можно подписаться на все события.
// sliderElement.noUiSlider.on('update', (...rest) => {
//   console.log(rest);
// });

// Если положение слайдера изменилось, нужно изменить и значение в поле ввода. Получим актуальное значение слайдера с помощью метода .get() и запишем его в свойство value поля ввода.
sliderElement.noUiSlider.on('update', () => {
  valueElement.value = sliderElement.noUiSlider.get();
});

// Рассмотрим ситуацию, когда нужно менять «на лету» какие-либо параметры слайдера. Например, галочка «Я оптовик» будет в десять раз уменьшать цену и шаг.
// добавим чекбокс в разметку "Я оптовик" емкость поля будет снижаться в 10 раз если этот чекбокс будет выбран

// Добавим обработчик на выбор галочки с условием, от которого зависит, какие параметры передать слайдеру.

// Для обновления слайдера используем специальный метод .updateOptions(). Попробуйте поставить и убрать галочку, происходит что-то странное... Начальное значение скачет.
// Поэтому начальное значение тоже нужно устанавливать, если мы меняем границы слайдера. Можно через ключ start в передаваемом объекте, а можно вызовом метода .set() у свойства noUiSlider элемента. Особенность второго способа, что он более универсальный. Обратите внимание, что в случае обновления нам не нужно менять значение поля «Цена» руками, потому что и вызов .updateOptions(), и вызов set приведут к событию update, на которое у нас добавлен обработчик
specialElement.addEventListener('change', (evt) => {
  if (evt.target.checked) {
    // цена и шаг в 10 раз меньше
    sliderElement.noUiSlider.updateOptions({
      range: {
        min: 0,
        max: 10,
      },
      step: 0.1,
      start: 8,
      // start: valueElement.value / 10, // для пропорционального перехода например было 65 ставим галку "я оптовик" и ползунок будет на значении 6.5
    });
    sliderElement.noUiSlider.set(valueElement.value);
  } else {
    // цена по умолчанию
    sliderElement.noUiSlider.updateOptions({
      range: {
        min: 0,
        max: 100,
      },
      step: 1,
      // start: 80, // ожно и так, но установим значение слайдера для разнообразия через метод set()
      // start: valueElement.value * 10,// для пропорционального перехода например было 6.5 снимаем галку "я оптовик" и ползунок будет на значении 65
    });
    sliderElement.noUiSlider.set(80);
  }
});

// Нам может понадобиться заблокировать слайдер. Для этого элементу слайдера нужно добавить атрибут disabled со значением true. А чтобы разблокировать слайдер, этот атрибут надо убрать. Обратите внимание, добавлять и убирать атрибут следует с помощью методов .setAttribute() и .removeAttribute().
sliderElement.setAttribute('disabled', true);
// разблокируем слайдер методом removeAttribute()
sliderElement.removeAttribute('disabled');

// И последнее, что может пригодиться, удаление слайдера. Для этого нужно вызвать метод .destroy(). Обратите внимание, что метод мы вызываем у свойства noUiSlider элемента.

// sliderElement.noUiSlider.destroy();
// слайдер пропал со страницы, реально уничтожен в отдичии к примеру от display: none;
