// Шаг 1 Ранее мы разобрали, как использовать библиотеку для валидации PristineJS в простых случаях, когда достаточно расставить атрибуты в HTML. Теперь давайте рассмотрим сложные случаи, когда атрибутов недостаточно, и сперва удалим их.
// Шаг 2 Чтобы описать валидации в JavaScript, нужно вызвать метод .addValidator(). Метод принимает несколько аргументов. Первый — элемент формы, который мы хотим валидировать. Давайте реализуем ту же валидацию поля ввода имени питомца, но уже через JavaScript. Для этого найдём поле через .querySelector() и передадим Pristine.
// Шаг 3 Вторым аргументом в .addValidator() нужно передать функцию проверки. Можно передавать по месту, но удобнее объявить функцию выше и передать по ссылке. Назовём её validateNickname. Функция проверки обязательно должна возвращать true или false, в зависимости от того, валидно ли поле. Pristine будет вызывать функцию проверки каждый раз, когда потребуется провалидировать форму. Первым параметром будет передано актуальное значение поля. Опишем условие, основываясь на длине значения.
// Шаг 4 Третьим аргументом нужно передать сообщение об ошибке. Попробуйте теперь отправить форму, нажав кнопку «Заказать». Если поле с именем пустое, или имя короче двух символов, или длиннее 50 символов — мы увидим ошибку.

// Шаг 5 Это было несложно. Теперь давайте попробуем провалидировать оставшиеся поля. Но сперва зафиксируем условия валидации.
  // УСЛОВИЯ

  // Максимальное количество зависит от размера упаковки:
  // S-размер - 10 штук, M-размер - 5 штук в одни руки

  // Доставка возможна на следующий день или на выходных
  // Самовывоз в этот же день, либо на следующий

// Шаг 6 Дальше всё аналогично. Сперва находим поле, в этот раз запишем его в переменную, после передаём в .addValidator(). Так же для валидации нам потребуются данные, соотношение количества и размера. Такие вещи удобно хранить в объекте, поэтому заведём maxAmount. Ключ — размер упаковки, значение — максимальное количество в одни руки.

// Шаг 7 Далее опишем функцию валидации. Здесь тоже обычное условие. Из необычного — как мы добавляем данные для условия. Для этого во время каждой проверки нам нужно найти выбранный на текущий момент размер — переменная unit — после по размеру достать максимально возможное количество из maxAmount, и только потом сравнить со значением в поле.

// Шаг 8 Похожим образом выстроим сообщение ошибки. Обратите внимание, что вместо простой строчки с текстом в этот раз мы передаём функцию, которая этот текст генерирует. Так тоже можно! Это удобно, когда у вас текст ошибки вариативный и зависит от каких-то условий, как у нас. Готово.

// Шаг 9 Вишенкой на торте можно сделать проверку количества в момент выбора другого размера. Это удобно, когда пользователь сперва ввёл количество, а потом решил изменить размер. Для этого достаточно добавить обработчики событий 'change' на выбор размера, а внутри обработчика вызывать валидацию pristine.validate(amountField). Попробуйте вписать количество 10 и после выбрать размер M, сразу появится сообщение об ошибке.

// Шаг 10 Теперь переходим к самому сложному — проверке сопоставления типа доставки с датой. Мы также будем использовать подход с соотношением, только в этот раз у нас может быть несколько вариантов. Поэтому ключами в объекте deliveryOption будут типы доставки, а значениями — массивы с возможными датами. А ещё .addValidator() мы вызовем на обоих выпадающих списках, ведь ошибку нужно показать всё равно, не важно, что первым выбрал пользователь.

// Шаг 11 Далее опишем функцию проверки. Логика её проста: если по выбранному типу доставки есть выбранный день — то есть присутствует в массиве — всё отлично. Если нету — будет показана ошибка.

// Шаг 12 А чтобы ошибка показалась, нужно написать функцию, которая её генерирует. Текст ошибки мы построили полностью на данных разметки, ещё и просклоняли. Много кода, зато красиво. Всё готово, попробуйте отправить пустую форму. Все ошибки на месте, все понятны пользователю.

// Шаг 13 И финальный штрих — если не хотите, чтобы Pristine валидировала форму по мере ввода, то передайте при подключении третьим аргументом false.


// шаг 1
const orderForm = document.querySelector('.form');

orderForm.querySelector('#nickname').removeAttribute('minLength'); //От себя. что бы не менять разметку удалим атрибут min-length у инпута c id nicknameс помощью JS, что-бы он не мешал нам и не добавлялясь строка при

const pristine = new Pristine(orderForm, {
    classTo: 'form__item', // Элемент, на который будут добавляться классы
    errorClass: 'form__item--invalid', // Класс, обозначающий невалидное поле
    successClass: 'form__item--valid', // Класс, обозначающий валидное поле
    errorTextParent: 'form__item', // Элемент, куда будет выводиться текст с ошибкой
    errorTextTag: 'span', // Тег, который будет обрамлять текст ошибки
    errorTextClass: 'form__error' // Класс для элемента с текстом ошибки
  },
  // false // шаг 13 если не хотите, чтобы Pristine валидировала форму по мере ввода, то передайте при подключении третьим аргументом false.
);

function validateNickname (value) { // шаг 3
  return value.length >= 2 && value.length <= 50;
};

pristine.addValidator( // шаг 2
  orderForm.querySelector('#nickname'),
  validateNickname, // шаг 3
  'От 2 до 50 символов' // шаг 4
);

// шаг 5
const amountField = orderForm.querySelector('#amount'); // шаг 6
const maxAmount = { // шаг 6
  's': 10,
  'm': 5
};

function validateAmount (value) { // шаг 7
  const unit = orderForm.querySelector('[name="unit"]:checked'); // таким образом осуещствляется поиск выбранного type="radio" c name="unit" элемента который выбран радиоточкой
  return value.length && parseInt(value) <= maxAmount[unit.value]; // value.length булева проверка на присутвие содержимого value, и следущая проверка Метод parseInt() в JavaScript принимает в качестве аргумента строковое значение и возвращает целое число, которое соответствует указанному основанию системы счисления и стравнивает его с maxAmount[unit.value] (при этом unit.value вернет либо 's' либо 'm' в зависимости от выбранного элемента и далее обратится по свойству s или m к значению свойства в обьекте maxAmount )
};

function getAmountErrorMessage () { // шаг 8
  console.log('работает getAmountErrorMessage')
  const unit = orderForm.querySelector('[name="unit"]:checked');
  return `Не больше ${maxAmount[unit.value]} штук в одни руки`;
}

pristine.addValidator(
  amountField, // шаг 6
  validateAmount, // шаг 7
  getAmountErrorMessage // шаг 8
);

// шаг 9 начало vvvvvvvv
function onUnitChange () { // функция которая будет навешиваться на обработчики событий  типа 'change'
  amountField.placeholder = maxAmount[this.value]; // в плейсхолдер попадает value элемента который будет на котором стработает событие так эта функция добавиться ниже по коду в обработччик события на элемент типа радио...
  pristine.validate(amountField); // команда для pristine: проверить поле amountField имеющимся валидатором(или валидаторами если их несколько на одно поле)
};

orderForm
  .querySelectorAll('[name="unit"]') // ищем в форме все элементы с атрибутом name="unit" и собыраем в коллекцию
  .forEach((item) => item.addEventListener('change', onUnitChange)); // перебираем коллекцию и на каждый элемент коллекции накидываем обработчик на событие change
// шаг 9 конец ^^^^^^^^^



const deliveryField = orderForm.querySelector('[name="delivery"]'); // шаг 10  // нашли select "доставка/самовывоз"
const dateField = orderForm.querySelector('[name="date"]'); // шаг 10 // нашли select "сегодня/завтра/навыходных"
const deliveryOption = { // шаг 10
  'Доставка': ['Завтра','На выходных'],
  'Самовывоз':['Сегодня','Завтра'],
};

function validateDelivery () { // шаг 11
  return deliveryOption[deliveryField.value].includes(dateField.value);  //  в этой строке в сохраненном в переменой  deliveryField (select "доставка/самовывоз") возьмем value (вернет одно из доставка или самовывоз), потом это ипольуется как ключ к обьекту deliveryOption по которому на вернется один из массивов либо ['Завтра','На выходных'] либо ['Сегодня','Завтра'] далее идем к методу includes который вернет нам true если выбранный пункт в селекте "сегодня/завтра/навыходных" (получен как dateField.value ) совпадет с одним элементом массива полученного из выражения deliveryOption[deliveryField.value] о котором писал сразу
}

function deliveryErrorMessage () { // шаг 12
  return `
    ${deliveryField.value}
    ${dateField.value.toLowerCase()}
    ${deliveryField.value === 'Доставка' ? 'невозможна' : 'невозможен'}
  `
}

pristine.addValidator(
  deliveryField, // шаг 10
  validateDelivery, // шаг 11
  deliveryErrorMessage, // шаг 12
);

pristine.addValidator(
  dateField,  // шаг 10
  validateDelivery, // шаг 11
  deliveryErrorMessage, // шаг 12
);

// шаг 1
orderForm.addEventListener('submit', (evt) => {
  evt.preventDefault();
  pristine.validate();
})
