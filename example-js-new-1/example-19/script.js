
const print = (message) => console.log(message);

// print('Раз');
// print('Два');
// print('Три');

// JavaScript — синхронный язык. Команды выполняются по одной сверху вниз по файлу. Опишем функцию-принтер print, задача которой выводить сообщения. Сколько раз мы её вызовем, столько сообщений мы увидим. Порядок вызовов и выводов будет сохранён, а весь код отработает разом. Иными словами, всё будет синхронно.
// А что делать, если нужна асинхронность? Например, мы хотим отложить печать на 1000 миллисекунд. Самый простой способ отложить вызов функции — использовать штатный метод setTimeout. Интерфейс у него прост: первым аргументом нужно передать колбэк, который нужно вызвать, а вторым аргументом — задержку, таймаут, в миллисекундах.

// setTimeout(() => {}, 1000);

// Передадим колбэк, который будет вызывать нашу функцию print. В качестве задержки укажем 1000 миллисекунд, это 1 секунда.

// setTimeout(() => {
//   print('Четыре');
// }, 1000);

// Если передать не колбэк, а сразу нашу функцию, потеряем аргументы. Совсем как в случае с addEventListener. Поэтому в консоль выведется undefined. setTimeout(print, 1000); выдаст undefined

// print('Раз');
// setTimeout(() => {
//   print('Четыре');
// }, 1000);
// print('Два');
// print('Три');

// Главное, что нужно запомнить, что асинхронная операция выполнится после синхронных. Куда бы мы не переместили setTimeout, вызов колбэка произойдёт, когда закончатся синхронные операции. Поэтому в консоли мы по-прежнему видим: Раз, Два, Три, Четыре.
// Даже если время задержки будет 0, это всё равно асинхронная операция, а значит выполнится после синхронных.

// А вот «между собой» колбэки setTimeout выполняются по задержке, поэтому в консоль сначала выведется Пять, и только потом Четыре.

// print('Раз');
// print('Два');
// setTimeout(() => {
//   print('Четыре');
// },1000 );

// setTimeout(() => {
//   print('Пять');
// }, 500);

// print('Три');

// Результат:
//  log: "Раз"
// log: "Два"
// log: "Три"
// log: "Пять"
// log: "Четыре"

// В случае одинаковых задержек очерёдность определяется порядком объявления setTimeout, поэтому в консоль выведется Четыре, а потом Пять.

// print('Раз');
// print('Два');
// setTimeout(() => {
//   print('Четыре');
// },1000 );

// setTimeout(() => {
//   print('Пять');
// }, 1000);

// print('Три');

// Результат:
//  log: "Раз"
// log: "Два"
// log: "Три"
// log: "Четыре"
// log: "Пять"


// Бывает так, что нужно отозвать setTimeout до того, как колбэк будет вызван. Для этого существует отдельный метод clearTimeout. В качестве аргумента этому методу нужно передать уникальный идентификатор, который возвращает setTimeout. clearTimeout синхронный, поэтому он удалит наш таймаут с принтером ещё до того, как колбэк будет вызван, поэтому Четыре в консоль не выведется никогда.

// print('Раз');
// print('Два');

// const timeoutId = setTimeout(() => {
//     print('Четыре');
// }, 0);

// print('Три');

// clearTimeout(timeoutId);


// Помимо setTimeout существует setInterval. setInterval отличается от setTimeout лишь тем, что вызывает переданный колбэк не один раз, а бесконечное количество раз с интервалом в переданную задержку. Поэтому с setInterval всегда нужно использовать clearInterval.


print(1);
print(2);

let i = 4;
const intervalId = setInterval(() => {
    print(i++);
}, 10000);

print(3);

// clearInterval(intervalId);
