<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p title="спасибо за покупку">Какой то текст</p>
  <script src="./script.js"></script>

  <pre>
    3.1. Компоненты в React
В предыдущих разделах мы научились делить интерфейсы на независимые части, называемые компонентами. Теперь пришло время разобраться, как создавать компоненты в React.

Библиотека React предоставляет два типа компонентов:

классовые компоненты,
функциональные компоненты.
Функциональный компонент представляет собой функцию, которая получает данные и возвращает элемент интерфейса в качестве результата своего вызова. Классовый компонент представляет собой JavaScript-класс, унаследованный от класса Component, предоставляемого пакетом React. Данные в классовый компонент передаются через конструктор, а нужное поведение реализуется через переопределение методов базового класса, в частности метода render для реализации отрисовки компонента.

Классовые компоненты значительно сложнее функциональных, для их использования нужно понимать механизмы наследования в JavaScript. В то же время функция — это идеальный инструмент для преобразования данных в разметку интерфейса. В результате код на классовых компонентах часто выглядит громоздким и избыточным. Поэтому, а также благодаря механизму React-хуков (о котором мы поговорим в следующих главах), большинство разработчиков отдаёт предпочтение именно функциональным компонентам.

Классовые компоненты используются редко, иногда их применяют для реализации элементов интерфейса со сложной или специфичной логикой, которую неудобно описывать в одной функции. Разработкой таких компонентов обычно занимаются React-программисты: верстальщики их не создают.

В рамках курса мы рассмотрим только функциональные компоненты. Они более современные и лёгкие в освоении, а также идеально подходят для задач вёрстки.

Функциональные компоненты
Функциональный компонент в React — это JavaScript-функция, которая на входе получает объект с данными, нужными для отрисовки компонента (называемыми props), а на выходе возвращает React-элемент.

React-элемент — это JavaScript-объект, описывающий узел DOM-дерева. Он имеет специальный формат, который React умеет обрабатывать и отображать на странице. Для создания таких объектов библиотека React предоставляет метод React.createElement.

Таким образом, чтобы создать на странице разметку вида...

<p>Тяжело читать <b>React.createElement</b>!!!</p>

        Копировать



... можно написать React-компонент:

import React from "react";

function HelloReact() {
  // не нужно думать, что это такое, дальше мы будем использовать JSX
  return React.createElement(
    "p",
    {},
    "Тяжело читать ",
    React.createElement("b", {}, "React.createElement"),
    "!!!"
  );
}

        Копировать



Вызовы React.createElement не выглядят интуитивно понятными, но не нужно сейчас в них разбираться. Дело в том, что при написании React-компонентов прямой вызов React.createElement обычно не применяется, а используется специальный синтаксис JSX. Подробнее о JSX мы поговорим в следующей главе. Сейчас для понимания примеров можно думать о нём как о магии, которая позволяет писать HTML-код внутри JavaScript-кода и шаблонизировать его, указывая в фигурных скобках JavaScript-выражения.

В курсе мы будем использовать только JSX. React.createElement изучаться не будет, так как он практически не используется на практике.

C использованием JSX, чтобы создать на странице разметку вида:

<h1> Привет, Мир!!!</h1>

        Копировать



Можно написать компонент HelloWorld, который выводит традиционное приветствие:

import React from 'react';

function HelloWorld () {
  return (<h1> Привет, Мир!!!</h1>);
}

        Копировать



HelloWorld — это максимально простой компонент на React, он не получает данных и всегда выводит одно и то же приветствие.

Заглавная буква «H» в названии компонента HelloWorld не является опечаткой. В React принято именовать компоненты с большой буквы.

Несмотря на использование JSX, вариант на обычном HTML всё равно выглядит слегка проще, но давайте попробуем добавить немного данных. Вместе со статичным приветствием выведем имя пользователя, которое изначально неизвестно и может меняться. Одним только HTML теперь не обойтись. Без использования React мы бы могли написать следующий код:

<!-- index.html -->
<h1>Привет, Мир!!! Меня зовут <b class="js-name"></b>.</h1>

        Копировать



// index.js
function setName(name) {
  const nameWrapper = document.querySelector(".js-name");

  if (nameWrapper) {
    nameWrapper.textContent = name;
  }
}

setName("Вася");

        Копировать



Давайте проанализируем код из этого примера, у него можно заметить следующие недостатки:

Мы создали два файла: index.html — для разметки, index.js — для логики. Такое разделение разумно, но в то же время логика и вёрстка тесно связаны. Например, если изменить в вёрстке название класса js-name, не глядя в JavaScript, то код перестанет работать корректно. Точно так же изменения в JS в отрыве от вёрстки приведут к неработоспособности примера. В результате такое разделение оказывается неудобным, так как становится сложно держать оба файла в согласованном состоянии.

JavaScript-код выглядит недостаточно наглядным, в нём приходится последовательно вызывать методы DOM API, чтобы сначала найти нужный элемент, а потом его изменить. Если немного усложнить пример, то такой JavaScript-код быстро превратится в нечитаемую последовательность вызовов API. В результате будет сложно понять, к каким изменениям на странице приведёт вызов такого кода и какая в итоге разметка будет на странице.

Это типичная особенность императивного подхода, который описывает последовательность действий для достижения результата, а не сам желаемый результат. В итоге невозможно понять, какой будет результат, пока не разберёшь всю последовательность описанных в коде действий.

Эти недостатки не так страшны в небольших примерах, но такое решение быстро становится неприемлемым в более сложных приложениях, особенно в SPA, где в зависимости от действий пользователя нужно изменять целые страницы.

Тот же пример на React может выглядеть так:


import React from "react";

export default function HelloWorld(props) {
  return (
    <h1>
      Привет, Мир!!! Меня зовут <b>{props.name}</b>.
    </h1>
  );
}

        Копировать



Благодаря использованию JSX JavaScript-код и разметка интерфейса находятся рядом друг с другом в одном компоненте. Это очень удобно: сразу видно, к чему приводят изменения в логике или разметке, и их легче держать в согласованном состоянии. Само деление на компоненты помогает избежать увеличения файла с JavaScript-кодом, ведь каждый React-компонент принято хранить в отдельном файле.

Также в коде нет вызовов DOM API. Вместо них мы подставляем значение переменной props.name прямо в разметку JSX, используя синтаксис {JavaScript expression} — с ним мы детально познакомимся в следующей главе. Это позволяет описывать логику изменения имени в более наглядном декларативном формате. И вместо описания действий просто указывать, в какие части разметки какие данные нужно подставить.

Благодаря React больше не нужно думать о том, как найти нужный элемент в DOM-дереве, как его поменять или проверить наличие. Вместо этого внутри компонента описывается логика, как из входящих данных (props) получить нужную разметку реализуемого фрагмента интерфейса.

Логика описывается в синтаксисе JSX. Это значительно облегчает разработку, особенно если пример сложнее, чем HelloWorld.

Если внимательнее взглянуть на компонент HelloWorld из примера, то можно заметить, что сам по себе объект props в компоненте не используется — используется только его свойство name. В таких случаях объект propsдеструктурируют прямо внутри параметров функции.

Пример HelloWorld с деструктуризацией:

import React from 'react';

function HelloWorld ({name}) {
  return (<h1> Привет, Мир!!! Меня зовут  <b>{name}</b>.</h1>);
}

        Копировать



Так как React-компонент — это просто функция, мы можем описывать её с помощью стрелочных функций:

  import React from 'react';

  const HelloWorld = ({name}) => (<h1> Привет, Мир!!! Меня зовут  <b>{name}</b>.</h1>);

        Копировать



Компонент, описанный в виде стрелочной функции, лаконичнее обычного, так как можно опустить return. Однако он не такой наглядный. Какой вариант объявления функциональных компонентов использовать, зависит от принятых в проекте правил оформления кода. Мы будем использовать в учебнике обычные функции.

Каждый компонент в React принято хранить в отдельном JavaScript-файле c тем же именем, что и у компонента.

В предыдущих примерах из CodeSandbox мы не акцентировали внимание на том, как созданные компоненты попадают на страницу. Но пора в этом разобраться.

Чтобы вывести созданный компонент на страницу, нужно объяснить React, в каком месте HTML-документа его нужно отобразить. Для этого существует метод render. Первым параметром метод render получает элемент, который нужно вывести на страницу. Для того, чтобы получить метод render, нужно сначала создать объект из элемента DOM-дерева, в который нужно смонтировать компонент с помочью функции createRoot пакета react-dom.

Чтобы вывести компонент HelloWorld внутри HTML-элемента с id root, добавим в пример вызов render:

import React from 'react';
import { createRoot } from "react-dom/client";

function HelloWorld ({name}) {
  return (<h1>Привет, Мир!!! Меня зовут <b>{name}</b></h1>);
}
const rootElement = createRoot(document.getElementById('root'))
//Сейчас мы вызываем HelloWorld как функцию, в дальнейшем мы научимся делать это более грамотно
// через JSX
rootElement.render(HelloWorld({name: 'Иван'}));

        Копировать



В каком-то смысле результат работы rootElement.render напоминает appendChild из DOM API с той разницей, что rootElement.render принимает в качестве вставляемого элемента React-element, a appendChild работает с DOM-узлом.

Именно так в общих чертах в React устроена работа с компонентами.



    3.2. JSX
После знакомства с React-компонентами пришло время разобраться, что же такое JSX и зачем он нужен.

JSX — это не фрагмент HTML и не строка. Это расширение языка JavaScript.

Потребность в таком расширении возникает из-за того, что JavaScript является императивным языком программирования. Он удобен для описания логики работы приложения, но плохо подходит для описания декларативных элементов, таких как разметка страницы.

Разметку страницы гораздо легче описывать языком HTML, чем вызывать различные методы DOM API через JavaScript. Но HTML позволяет описывать только статику, которая не зависит от входных данных и действий пользователя. JSX изящно решает эту проблему, добавляя в JavaScript возможность использовать синтаксис, похожий на HTML, и встраивать в него выражения из JavaScript. Это становится возможным благодаря Babel, который предварительно превращает JSX в чистый JavaScript-код, заменяя теги и другие инородные для JavaScript конструкции JSX вызовами React.createElement. То есть JSX — своего рода синтаксический сахар над менее наглядным React.createElement.

В предыдущем примере для вывода приветствия мы написали код на JSX:

<h1>Привет, Мир!!! Меня зовут <b>{name}</b></h1>

        Копировать



Он выглядит как обычный HTML: легко и понятно. На обычном HTML это выглядело бы так:

<h1>Привет, Мир!!! Меня зовут <b>Вася</b></h1>

        Копировать



Из примеров видно, что единственное различие с HTML состоит в том, что сам по себе HTML (без JavaScript) позволяет писать только статику. В нём мы вынуждены явно указывать имя пользователя, что допустимо для тестового примера. Но в реальной жизни имя каждого пользователя будет меняться, поэтому мы не можем делать его статичным. А в примере на JSX используется синтаксис фигурных скобок, что позволяет выводить имя пользователя динамически, исходя из данных.

Фигурные скобки в JSX позволяют подставлять в разметку выражения из JavaScript. Это может быть как простая переменная name, так и более сложные выражения, например тернарные операторы или вызов функции. Таким образом, с JSX мы можем описывать интерфейс страницы, используя привычный HTML, и в то же время иметь возможности JavaScript для шаблонизации.

Следующий пример выводит цену покупки на основе цены товара и его количества, переданных компоненту через props. Также в зависимости от цены продукта подставляются разные title-атрибуты:

function Price ({productPrice, quantity}) {
  return (
    <p title = {productPrice < 1000 ? "лучшая цена" : "спасибо за покупку"} >
      Цена: {productPrice * quantity}
    </p>
  );
}

        Копировать



Если в компонент Price через props придут данные {productPrice: 2000, quantity: 2}, то он вернёт разметку:

<p title="спасибо за покупку">Цена: 4000</p>

        Копировать



А если, например, передать: {productPrice: 500, quantity: 10}, то  title изменится, и на выходе получится:

<p title="лучшая цена">Цена: 5000</p>

        Копировать



Как видно из примера, фигурные скобки можно использовать не только для описания содержимого тегов, но и для атрибутов.

Используя JSX, мы можем о нём думать как о привычном HTML, который можно писать прямо внутри JavaScript. Но важно помнить, что JSX только похож на HTML. На самом деле, он в конечном счёте будет преобразован в JavaScript-объекты. Этим обусловлено несколько особенностей JSX:

В отличие от HTML, в JSX все теги всегда должны быть закрыты.
В HTML допустимо и даже приветствуется не закрывать одиночные теги. Например, можно просто написать тег <img> и не закрывать его. Но в JSX нужно всегда закрывать все теги, в том числе и <img>: <img />. Теги без дочерних элементов принято сразу закрывать, например, вместо <div></div> пишут просто <div />. Конечно, в случае с <div> это не имеет большого смысла, но в дальнейшем мы научимся вставлять в JSX наши собственные компоненты, и там этот синтаксис окажется полезным.

Таким образом, следующий код абсолютно валиден для HTML:  <p> Порода красоты лицу не придаёт: <br> В селе и в городе цветок равно цветёт.</p>. Но если вставить его в компонент, то будет выведена ошибка. Всё дело в теге <br>, который не был закрыт. Если исправить эту ошибку, то компонент будет корректно отображён на странице.

JSX всегда должен иметь один родительский элемент.
JSX всегда представляет собой дерево. К примеру, код <p>Первый абзац</p><p>Второй абзац</p> в JSX окажется некорректным, потому что у тегов <p> нет общего родителя. Код из примера не отработает корректно, будет выведена ошибка:


function StaticText () {
  return (
    <p>Первый абзац</p>
    <p>Второй абзац</p>
  );
}

        Копировать



Это неудивительно. Даже если бы JSX умел обработать эту конструкцию, то, как упоминалось ранее, теги в итоге заменяются на вложенные друг в друга объекты React.element. При отсутствии общего родителя теги заменились бы на два не связанных между собой объекта, что вызвало бы ошибку в JavaScript.

Чтобы исправить ошибку, нужно обернуть теги <p> в общий родитель. Можно использовать любой тег, например: <div><p>Первый абзац</p><p>Второй абзац</p></div>. Такая разметка будет корректна с точки зрения JSX и не вызовет ошибок при рендеринге.

Однако порой лишний общий родитель в разметке бывает не нужен с точки зрения семантики. Да и в целом лишние узлы не способствуют улучшению производительности. В таких случаях можно использовать специальный элемент — React.Fragment. Если указать его в качестве родительского элемента, то JSX из предыдущего примера станет корректным, но при этом DOM-узла под React.Fragment создано не будет. То есть на страницу будут добавлены только дочерние элементы без React.Fragment. Переписав StaticText с использованием React.Fragment, мы получим корректный работающий код:


function StaticText () {
  return (
    <React.Fragment>
      <p>Первый абзац</p>
      <p>Второй абзац</p>
    </ React.Fragment>
  );
};

        Копировать



Если посмотреть разметку в браузере, то можно заметить, что React.Fragment присутствует только в JSX, а в конечной разметке его нет:

Разметка с React.Fragment.

В отличие от использования обёртки в виде <div>, которая будет выведена на страницу:

Разметка с

Нельзя использовать атрибут class.
В HTML для различных элементов можно указывать классы стилизации в атрибуте class. Например, <img class="image image_big">. Но в JavaScript class — это ключевое слово, а так как JSX трансформируется в JavaScript, то и в JSX нельзя использовать атрибуты с таким именем в разметке. Вместо class в JSX нужно использовать атрибут className и уже в нём указывать CSS-классы элемента. К примеру, вместо <img class="image image_big"> в JSX нужно писать <img className="image image_big" />.

Нельзя использовать атрибут for.
for — тоже ключевое слово в языке JavaScript. Поэтому вместо атрибута for, через который обычно связывают HTML-элемент label с элементом ввода, нужно использовать атрибут htmlFor. Всё точно так же, как и в случае с class, просто названия другие.

React должен находиться в области видимости кода с JSX (справедливо только для старых версий React и инструментов сборки).
JSX будет преобразован сборщиком проекта в вызов функции, а если точнее, в вызов функции React.createElement. Поэтому React должен находиться в области видимости кода с JSX, иначе неоткуда будет получить React.createElement. Соответственно, в файлы с JSX нужно импортировать React даже в тех случаях, когда он не используется непосредственно в коде.

Например, в компоненте Hello нет прямого вызова React. Поэтому может показаться, что import React from "react" можно убрать:

import React from "react";

function Hello() {
  return <div>Привет, Мир</div>;
}

        Копировать



Но это вызовет ошибку, так как в процессе сборки проекта JSX будет преобразован в вызов React.createElement. Код компонента примет вид:

import React from "react";

function Hello() {
  return React.createElement("div", {}, "Привет, Мир");
}

        Копировать



В этом коде использование React из неявного становится явным. Очевидно, что без объекта React в области видимости компонента вызов React.createElement приведёт к ошибке, потому что React будет undefined.

Современная версия React и инструменты сборки автоматически добавляют нужные для JSX методы в код (например, так настроен проект в CodeSandbox). В таких случаях писать import React from "react"; не нужно. Однако в примерах и демонстрациях мы всё равно будем это делать, чтобы вам было легче копировать примеры в локальные проекты.

Значения переменных true, false, null и undefined игнорируются при рендеринге. То есть на их месте ничего не будет выведено.
Если в JavaScript выполнить код  console.log(`<div>${undefined}</div>`);, то в консоль будет выведено <div>undefined</div>. Так происходит из-за того, что JavaScript, приводя undefined к строке, превращает его в строку вида: undefined. JSX подобные значения просто игнорирует и не выводит вообще. В следующем примере ничего не будет выведено на экран:

import React from "react";

function Empty() {
  return <div>{undefined}</div>;
}

export default Empty;

        Копировать



Стили для атрибута style можно указывать в виде JavaScript-объекта.
Это часто бывает удобно, потому что позволяет использовать JavaScript-переменные в качестве значений стилей. При этом названия свойств CSS, которые содержат «-», должны быть заменены на camelCase.

В следующем примере цвет фона для элемента с именем пользователя меняется на основе букв в его имени.

import React from "react";

function HelloWorld({
  name // Имя пользователя
}) {
  // Будем вычислять цвет, преобразовывая первые три символа имени
  // в значения rgb цветового пространства.
  const getColorFromName = (userName) => {
    // Если имя меньше трёх букв,
    // то вычислить цвет не получится — возвращаем белый.
    if (userName && userName.length > 2) {
      let result = "";
      for (let i = 0; i < 3; ++i) {
        // Для каждого из первых трёх символов выполняем преобразование в 16-ричную систему.
        // Для этого берём код символа,
        // преобразуем его в остаток от деления на 256
        // (чтобы гарантировать, что результат не превысит 255 — максимальное значение для цвета )
        // и переводим число в 16-ричную систему исчисления.
        result += (userName[i].charCodeAt(0) % 256).toString(16);
      }

      return result.toUpperCase();
    }

    return "FFFFFF";
  };
  return (
    <h1>
      Привет, Мир!!! Меня зовут{" "}
      <b style={{ backgroundColor: `#${getColorFromName(name)}` }}>{name}</b>
    </h1>
  );
}

export default HelloWorld;

        Копировать



Компоненты и JSX
Внутри JSX можно использовать не только стандартные теги, но и собственные компоненты. В этом случае название компонента становится именем тега, а props передаются через атрибуты.

В компоненте HelloWorld вынесем имя пользователя в отдельный компонент. Для этого создадим отдельный файл, в котором будет размещён код нового компонента, и назовём его user-name.

В примерах для краткости мы будем размещать несколько компонентов в одном файле. Но в реальных проектах лучше хранить каждый компонент в отдельном файле

Далее создадим в файле компонент UserName. Разметку для имени можно позаимствовать прямо из компонента HelloWorld -<b>{`${firstName} ${secondName}`}</b>, а динамические значения firstName и secondName поместим в props. В результате получится:

// user-name
import React from "react";

function UserName ({firstName, secondName}) {
  return (<b>{`${firstName} ${secondName}`}</b>);
}

export default UserName;

        Копировать



Теперь, когда компонент UserName готов, изменим HelloWorld таким образом, чтобы вместо своей разметки он использовал UserName для вывода имени. Для этого импортируем UserName в файл с компонентом HelloWorld и заменим в нём теги, описывающие имя пользователя, на компонент UserName.

Далее через атрибуты UserName нужно прокинуть props с именем пользователя из компонента HelloWorld в UserName. В результате HelloWorld примет вид.

// hello-world
import React from "react";
import UserName from "./user-name";

function HelloWorld({ firstName, secondName }) {
  return (
    <p>
      <span>Привет, Мир!!! Меня зовут: </span>
      <UserName firstName={firstName} secondName={secondName} />
    </p>
  );
}

export default HelloWorld;

        Копировать



Теперь компонент HelloWorld выводит только само приветствие, а вывод имени делегируется компоненту UserName, результаты работы которого будут подставлены в нужную часть разметки HelloWorld.

В результате всех манипуляций выводимый на экран результат не изменился, но код стал более гибким. Раньше разметка и логика отображения имени пользователя являлись частью компонента HelloWorld и не могли быть переиспользованы в других частях приложения в отрыве от приветствия. Но сейчас, обогатив проект компонентом UserName, мы получили возможность одинаково легко выводить имя пользователя в любой части страницы: как в приветствии, так и, например, в личном кабинете.

Сам компонент HelloWorld также стал легче и понятнее. Теперь он содержит только логику для вывода приветствия, для которой и был изначально создан. А вывод имени инкапсулирован в UserName и не мешает воспринимать код компонента для приветствия.

Подобный подход деления крупных компонентов на более мелкие применяется в React повсеместно. Разметка крупных компонентов состоит из маленьких, а маленьких — из ещё более простых. В результате страница на React обычно представляет собой набор вложенных друг в друга компонентов. А приём, когда из набора маленьких компонентов собирают более сложные элементы, называют композицией компонентов.

Важно отметить, что использование заглавной буквы в имени компонента для JSX является обязательным. Именно благодаря заглавной букве JSX понимает, что перед ним не тег с кастомным названием, а пользовательский компонент.

Если в предыдущем примере написать UserName с маленькой буквы, то имя пользователя перестанет выводиться на экран. Так произойдёт из-за того, что JSX интерпретирует <userName .../> не как команду вызова компонента userName, а как обычный HTML-тег с именем username. Это произойдёт, даже несмотря на наличие константы userName в коде. В свою очередь HTML-тег <username> от обычного <div> отличается по большей части только названием и не умеет обрабатывать атрибуты firstName и secondName, выводя их на экран.

В результате разметка страницы примет вид:

Вместо компонента отрендерился HTML-элемент.

Если вернуть заглавную букву UserNameComponent, то всё вновь будет работать корректно и на место <UserNameComponent ... />будет подставлена созданная им разметка:

Отрендерился компонент.

В предыдущих примерах в CodeSandbox вы, наверное, уже успели заметить код rootElement.render(HelloWorld({ name: "Вася" }));. Там мы вызываем компонент HelloWorld как функцию (потому что он и есть функция), передавая в параметрах нужные props.

Такой код был написан только потому, что мы ещё не умели использовать компоненты в JSX. Теперь этот код можно заменить на rootElement.render((<HelloWorld name="Вася" />));.

Синтаксис JSX предпочтительнее, чем прямой вызов компонентов как функций.

В дальнейшем мы будем использовать синтаксис JSX для добавления компонентов на страницу.

Как и с обычными тегами, в компоненты можно вкладывать дочерние элементы. Например, как в следующем примере:

import React from "react";

function UserName () {
  return (<b>пусто</b>);
}

export function HelloWorld ({firstName, secondName}) {
  return (<p>Привет, Мир!!! Меня зовут <UserName> {`${firstName} ${secondName}`} </UserName></p>);
}

        Копировать



Здесь внутрь UserName передаётся имя и фамилия пользователя как дочерний текстовый элемент. Но если посмотреть на результаты работы в CodeSandbox, то можно заметить, что имя и фамилия нигде не появились, а вместо них выводится «пусто», как и указано в компоненте UserName. Так происходит из-за того, что мы не указали, куда именно в UserName нужно вывести переданные дочерние элементы. Чтобы это указать, React предоставляет специальный props children. Все переданные в компонент дочерние элементы попадают в props children. Поэтому нужно использовать props children внутри компонента, чтобы вывести в нужном месте переданные ему дочерние элементы.

В следующем примере будут выведены дочерние элементы UserName через children.

import React from "react";

function UserName({ children }) {
  return <b>{children}</b>;
}

export function HelloWorld({ firstName, secondName }) {
  return (
    <p>
      Привет, Мир!!! Меня зовут{" "}
      <UserName> {`${firstName} ${secondName}`} </UserName>
    </p>
  );
}

        Копировать



Теперь имя, переданное в качестве дочернего элемента, выводится на страницу. А сам код благодаря children стал больше похож на привычный HTML, в котором контент располагается внутри тегов. JSX начал выглядеть так, словно у нас есть тег UserName и его контентом является строка с именем пользователя. Это улучшило читабельность компонента, стало понятнее, какие props являются как бы настройками компонента и что является его контентом.

Стоит отметить, что children отличается от обычных props в первую очередь синтаксисом. И ничто не мешает переписать предыдущий пример без использования children:

import React from "react";

function UserName({ name }) {
  return <b>{name}</b>;
}

export function HelloWorld({ firstName, secondName }) {
  return (
    <p>
      Привет, Мир!!! Меня зовут{" "}
      <UserName name={`${firstName} ${secondName}`} />
    </p>
  );
}

        Копировать



Здесь мы передаём имя в UserName через обычный props name, при этом программа работает точно так же, как и в примере с children. Таким образом, нет конкретного правила, когда использовать children, а когда — нет. Всё зависит от семантики разрабатываемых компонентов и правил проекта.
  </pre>

</body>
</html>
