<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <p title="спасибо за покупку">Какой то текст</p>
  <script src="./script.js"></script>

  <pre>
    3.1. Компоненты в React
В предыдущих разделах мы научились делить интерфейсы на независимые части, называемые компонентами. Теперь пришло время разобраться, как создавать компоненты в React.

Библиотека React предоставляет два типа компонентов:

классовые компоненты,
функциональные компоненты.
Функциональный компонент представляет собой функцию, которая получает данные и возвращает элемент интерфейса в качестве результата своего вызова. Классовый компонент представляет собой JavaScript-класс, унаследованный от класса Component, предоставляемого пакетом React. Данные в классовый компонент передаются через конструктор, а нужное поведение реализуется через переопределение методов базового класса, в частности метода render для реализации отрисовки компонента.

Классовые компоненты значительно сложнее функциональных, для их использования нужно понимать механизмы наследования в JavaScript. В то же время функция — это идеальный инструмент для преобразования данных в разметку интерфейса. В результате код на классовых компонентах часто выглядит громоздким и избыточным. Поэтому, а также благодаря механизму React-хуков (о котором мы поговорим в следующих главах), большинство разработчиков отдаёт предпочтение именно функциональным компонентам.

Классовые компоненты используются редко, иногда их применяют для реализации элементов интерфейса со сложной или специфичной логикой, которую неудобно описывать в одной функции. Разработкой таких компонентов обычно занимаются React-программисты: верстальщики их не создают.

В рамках курса мы рассмотрим только функциональные компоненты. Они более современные и лёгкие в освоении, а также идеально подходят для задач вёрстки.

Функциональные компоненты
Функциональный компонент в React — это JavaScript-функция, которая на входе получает объект с данными, нужными для отрисовки компонента (называемыми props), а на выходе возвращает React-элемент.

React-элемент — это JavaScript-объект, описывающий узел DOM-дерева. Он имеет специальный формат, который React умеет обрабатывать и отображать на странице. Для создания таких объектов библиотека React предоставляет метод React.createElement.

Таким образом, чтобы создать на странице разметку вида...

<p>Тяжело читать <b>React.createElement</b>!!!</p>

        Копировать



... можно написать React-компонент:

import React from "react";

function HelloReact() {
  // не нужно думать, что это такое, дальше мы будем использовать JSX
  return React.createElement(
    "p",
    {},
    "Тяжело читать ",
    React.createElement("b", {}, "React.createElement"),
    "!!!"
  );
}

        Копировать



Вызовы React.createElement не выглядят интуитивно понятными, но не нужно сейчас в них разбираться. Дело в том, что при написании React-компонентов прямой вызов React.createElement обычно не применяется, а используется специальный синтаксис JSX. Подробнее о JSX мы поговорим в следующей главе. Сейчас для понимания примеров можно думать о нём как о магии, которая позволяет писать HTML-код внутри JavaScript-кода и шаблонизировать его, указывая в фигурных скобках JavaScript-выражения.

В курсе мы будем использовать только JSX. React.createElement изучаться не будет, так как он практически не используется на практике.

C использованием JSX, чтобы создать на странице разметку вида:

<h1> Привет, Мир!!!</h1>

        Копировать



Можно написать компонент HelloWorld, который выводит традиционное приветствие:

import React from 'react';

function HelloWorld () {
  return (<h1> Привет, Мир!!!</h1>);
}

        Копировать



HelloWorld — это максимально простой компонент на React, он не получает данных и всегда выводит одно и то же приветствие.

Заглавная буква «H» в названии компонента HelloWorld не является опечаткой. В React принято именовать компоненты с большой буквы.

Несмотря на использование JSX, вариант на обычном HTML всё равно выглядит слегка проще, но давайте попробуем добавить немного данных. Вместе со статичным приветствием выведем имя пользователя, которое изначально неизвестно и может меняться. Одним только HTML теперь не обойтись. Без использования React мы бы могли написать следующий код:

<!-- index.html -->
<h1>Привет, Мир!!! Меня зовут <b class="js-name"></b>.</h1>

        Копировать



// index.js
function setName(name) {
  const nameWrapper = document.querySelector(".js-name");

  if (nameWrapper) {
    nameWrapper.textContent = name;
  }
}

setName("Вася");

        Копировать



Давайте проанализируем код из этого примера, у него можно заметить следующие недостатки:

Мы создали два файла: index.html — для разметки, index.js — для логики. Такое разделение разумно, но в то же время логика и вёрстка тесно связаны. Например, если изменить в вёрстке название класса js-name, не глядя в JavaScript, то код перестанет работать корректно. Точно так же изменения в JS в отрыве от вёрстки приведут к неработоспособности примера. В результате такое разделение оказывается неудобным, так как становится сложно держать оба файла в согласованном состоянии.

JavaScript-код выглядит недостаточно наглядным, в нём приходится последовательно вызывать методы DOM API, чтобы сначала найти нужный элемент, а потом его изменить. Если немного усложнить пример, то такой JavaScript-код быстро превратится в нечитаемую последовательность вызовов API. В результате будет сложно понять, к каким изменениям на странице приведёт вызов такого кода и какая в итоге разметка будет на странице.

Это типичная особенность императивного подхода, который описывает последовательность действий для достижения результата, а не сам желаемый результат. В итоге невозможно понять, какой будет результат, пока не разберёшь всю последовательность описанных в коде действий.

Эти недостатки не так страшны в небольших примерах, но такое решение быстро становится неприемлемым в более сложных приложениях, особенно в SPA, где в зависимости от действий пользователя нужно изменять целые страницы.

Тот же пример на React может выглядеть так:


import React from "react";

export default function HelloWorld(props) {
  return (
    <h1>
      Привет, Мир!!! Меня зовут <b>{props.name}</b>.
    </h1>
  );
}

        Копировать



Благодаря использованию JSX JavaScript-код и разметка интерфейса находятся рядом друг с другом в одном компоненте. Это очень удобно: сразу видно, к чему приводят изменения в логике или разметке, и их легче держать в согласованном состоянии. Само деление на компоненты помогает избежать увеличения файла с JavaScript-кодом, ведь каждый React-компонент принято хранить в отдельном файле.

Также в коде нет вызовов DOM API. Вместо них мы подставляем значение переменной props.name прямо в разметку JSX, используя синтаксис {JavaScript expression} — с ним мы детально познакомимся в следующей главе. Это позволяет описывать логику изменения имени в более наглядном декларативном формате. И вместо описания действий просто указывать, в какие части разметки какие данные нужно подставить.

Благодаря React больше не нужно думать о том, как найти нужный элемент в DOM-дереве, как его поменять или проверить наличие. Вместо этого внутри компонента описывается логика, как из входящих данных (props) получить нужную разметку реализуемого фрагмента интерфейса.

Логика описывается в синтаксисе JSX. Это значительно облегчает разработку, особенно если пример сложнее, чем HelloWorld.

Если внимательнее взглянуть на компонент HelloWorld из примера, то можно заметить, что сам по себе объект props в компоненте не используется — используется только его свойство name. В таких случаях объект propsдеструктурируют прямо внутри параметров функции.

Пример HelloWorld с деструктуризацией:

import React from 'react';

function HelloWorld ({name}) {
  return (<h1> Привет, Мир!!! Меня зовут  <b>{name}</b>.</h1>);
}

        Копировать



Так как React-компонент — это просто функция, мы можем описывать её с помощью стрелочных функций:

  import React from 'react';

  const HelloWorld = ({name}) => (<h1> Привет, Мир!!! Меня зовут  <b>{name}</b>.</h1>);

        Копировать



Компонент, описанный в виде стрелочной функции, лаконичнее обычного, так как можно опустить return. Однако он не такой наглядный. Какой вариант объявления функциональных компонентов использовать, зависит от принятых в проекте правил оформления кода. Мы будем использовать в учебнике обычные функции.

Каждый компонент в React принято хранить в отдельном JavaScript-файле c тем же именем, что и у компонента.

В предыдущих примерах из CodeSandbox мы не акцентировали внимание на том, как созданные компоненты попадают на страницу. Но пора в этом разобраться.

Чтобы вывести созданный компонент на страницу, нужно объяснить React, в каком месте HTML-документа его нужно отобразить. Для этого существует метод render. Первым параметром метод render получает элемент, который нужно вывести на страницу. Для того, чтобы получить метод render, нужно сначала создать объект из элемента DOM-дерева, в который нужно смонтировать компонент с помочью функции createRoot пакета react-dom.

Чтобы вывести компонент HelloWorld внутри HTML-элемента с id root, добавим в пример вызов render:

import React from 'react';
import { createRoot } from "react-dom/client";

function HelloWorld ({name}) {
  return (<h1>Привет, Мир!!! Меня зовут <b>{name}</b></h1>);
}
const rootElement = createRoot(document.getElementById('root'))
//Сейчас мы вызываем HelloWorld как функцию, в дальнейшем мы научимся делать это более грамотно
// через JSX
rootElement.render(HelloWorld({name: 'Иван'}));

        Копировать



В каком-то смысле результат работы rootElement.render напоминает appendChild из DOM API с той разницей, что rootElement.render принимает в качестве вставляемого элемента React-element, a appendChild работает с DOM-узлом.

Именно так в общих чертах в React устроена работа с компонентами.
  </pre>
</body>
</html>
